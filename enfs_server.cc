
/*
 * ENFS v1.0
 * https://github.com/robin-thomas/ENFS
 * Copyright 2015 Robin Thomas.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <queue>
#include <arpa/inet.h>
#include <pthread.h>
#include <semaphore.h>
#include <openssl/ssl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "rsa.h"
#include "server_fs.h"

#define CONNECT_QUEUE 20
#define SERVER_PORT 5050
#define THREAD_WORKERS 100
#define ENFS_DIR "/tmp/.enfs/"
#define SPATH "/tmp/.enfs"


std::queue <pthread_t> Workers;
sem_t workPool;


// Initialize the set of work
void initWorkers() {
  pthread_t workers[THREAD_WORKERS];
  for(int i = 0; i < THREAD_WORKERS; i++) {
    Workers.push(workers[i]);
  }
}


// Function to provide a client with an available worker
pthread_t getWorker() {
  pthread_t worker = Workers.front();
  Workers.pop();
  return worker;
}


// Initializ the server
// It shall load the private key and the X509 certificate
bool serverInit() {
  printf("Generating %d-bit RSA keys...\n", RSA_KEY_SIZE);
  printf("Set the password [26 chars]: ");
  scanf("%s", upass);
  EVP_PKEY* pkey = generate_key();
  if (!pkey) {
    return false;
  }

  printf("Generating X509 certificate...\n");
  X509* x509 = generate_x509(pkey);
  if (!x509) {
    return false;
  }

  printf("Writing key and certificate to disk...\n");
  bool ret = write_to_disk(pkey, x509, SPATH, upass);
  EVP_PKEY_free(pkey);
  X509_free(x509);

  if (ret) {
    return true;
  } else {
    return false;
  }
}


// Client Init Request
// Client is connecting to the server for the first time.
// Generate a 10-character random code and send it to client.
// Client should send the code with every file system call.
// Its used to uniquely identify the client
void clientInit(SSL* ssl) {
  // Generate a random 10 character string
  const char alpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  std::string s = "";
  size_t str_len = strlen(alpha);
  srand(time(NULL));
  for (int i = 0; i < 10; i++) {
    s += alpha[rand() % str_len];
  }

  std::string usrRoot = ENFS_DIR + s;
  int stat = mkdir(usrRoot.c_str(), S_IRWXU);
  if (stat != 0 && !(stat == -1 && errno == EEXIST)) {
    fprintf(stderr, "Unable to create user root directory");
  }

  std::string conf = std::string(ENFS_DIR) + "users";
  int fd = open(conf.c_str(), O_CREAT | O_WRONLY | O_APPEND, S_IRWXU);
  if (fd < 0) {
    fprintf(stderr, "Unable to create file\n");
  } else {
    std::string str = std::string(s) + "\n";
    write(fd, str.c_str(), str.size());
    close(fd);
  }

  printf("Client code: %s\n", s.c_str());
  SSL_write(ssl, s.c_str(), s.size());
}


// Client Authentication Request
// Check whether the code sent by client is valid
// Code is generated by server, when client connects
// to the server for the first time
void clientAuth(SSL* ssl, const std::string& key) {
  FILE* fp;
  std::string path = std::string(ENFS_DIR) + "users";
  if ((fp = fopen(path.c_str(), "r")) != NULL) {
    char buf[BUF_SIZE];
    while (fgets(buf, BUF_SIZE, fp)) {
      buf[strlen(buf) - 1] = '\0';
      if (key.compare(buf) == 0) {
        SSL_write(ssl, key.c_str(), key.size());
        return;
      }
    }
    fprintf(stderr, "Client code not found\n");
  }
  fclose(fp);
}


// Parse the data from the data, and check for valid client request
// If yes, based on the request, perform the required operation
void serviceRequest(SSL* ssl) {
  // Connect to cluent and read the data sent by client
  if (SSL_accept(ssl) != 1) {
    fprintf(stderr, "Unable to connect to client\n");
    return;
  }
  char buf[BUF_SIZE];
  memset(buf, 0, BUF_SIZE);
  int bytes = SSL_read(ssl, buf, sizeof buf);
  std::string tmp = buf;
  if (bytes < 0) {
    fprintf(stderr, "Unable to read from client\n");
    return;
  }

  // Determine the type of request
  char ch = tmp[0];
  tmp.erase(0, 1);
  switch (ch) {
    case '1': {
      clientInit(ssl);
      break;
    }
    case '2': {
      clientAuth(ssl, tmp);
      break;
    }
    case '3': {
      clientFuse(ssl, tmp);
      break;
    }
    default: {
      printf("Invalid client request\n");
    }
  }

  // Destroy the connection to the client
  int conn = SSL_get_fd(ssl);
  SSL_free(ssl);
  shutdown(conn, 2);
  if (close(conn) == -1) {
    fprintf(stderr, "Unable to close the socket!\n");
  }
}


// Helper function for multithreading
static void *threadHelper(void *arg) {
  SSL* ssl = (SSL*)arg;
  serviceRequest(ssl);
  Workers.push(pthread_self());
  sem_post(&workPool);
  return NULL;
}


// Set the socket to listen for any incoming client requests
// Since it uses thread pool, each client shall get a worker
// if one is available. If not, they are placed in the queue,
// until a worker becomes free.
// If the queue is full, and a new client request comes, the
// request is dropped.
int openListener(int port) {
  // Create the Socket
  int sockfd, set = 1 ;
  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
    fprintf(stderr, "Unable to create server socket!\n");
    return -1;
  }
  setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &set, sizeof(set));

  // Initialize the socket structure
  struct sockaddr_in address;
  bzero(&address, sizeof(address));
  address.sin_family      = AF_INET;
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port        = htons(port);

  // Bind socket address to socket
  if (bind(sockfd, (struct sockaddr*) &address, sizeof(address)) == -1) {
    fprintf(stderr, "Cannot bind to the socket!\n");
    return -1;
  }

  // Convert the socket to a listening socket
  if (listen(sockfd, CONNECT_QUEUE) == -1) {
    fprintf(stderr, "Unable to make the socket a listening socket!\n");
    return -1;
  }

  return sockfd;
}


// Main function
int main(int argc, char* argv[]) {

  try {

    // Create ENFS directory to store client files
    printf("\nReading configuration files...\n");
    std::string path = SPATH;
    int stat = mkdir(path.c_str(), S_IRWXU | S_IRGRP | S_IROTH);
    if (stat != 0 && !(stat == -1 && errno == EEXIST)) {
      throw "Unable to create ENFS directory";
    }
    path = std::string(SPATH) + "/pkey";
    stat = mkdir(path.c_str(), S_IRWXU | S_IRGRP | S_IROTH);
    if (stat != 0 && !(stat == -1 && errno == EEXIST)) {
      throw "Unable to create ENFS configuration directory";
    }

    // Initialize the server for SSL
    printf("Initializing server...\n");
    SSL_CTX* ctx = init();
    if (ctx == NULL) {
      fprintf(stderr, "Unable to initialize server\n");
      return 1;
    }

    // Start the server
    printf("Starting server...\n");
    initOpenSSL();
    if (!stat) {
      if (serverInit() == false) {
        throw "Unable to start server";
      }
    } else {
      printf("Enter the password [26 chars]: ");
      scanf("%s", upass);
    }

    // Load the private key and X509 certificate
    printf("Loading certificates...\n");
    SSL_CTX_set_default_passwd_cb(ctx, pem_passwd_cb);
    if (loadCert(ctx, std::string(SPATH) + "/" + CERT_FILE, std::string(SPATH) + "/" + KEY_FILE) == false) {
      return 1;
    }

    // Create Worker Pool
    initWorkers();
    sem_init(&workPool, 0, THREAD_WORKERS);

    // Create the Socket
    int server = openListener(SERVER_PORT);
    if (server < 0) {
      return 1;
    }

    // Loop indefintely to accept any connections
    printf("Waiting for a client connection request...\n");
    while (true) {
      int client;
      struct sockaddr_in addr;
      socklen_t len = sizeof(addr);
      bzero(&addr, len);
      if ((client = accept(server, (struct sockaddr*)&addr, &len)) == -1) {
        fprintf(stderr, "Unable to accept any connections!\n");
        return 1;
      }

      SSL* ssl = SSL_new(ctx);
      if (ssl == NULL) {
        handle_openssl_error();
      } else {
        sem_wait(&workPool);
        if (SSL_set_fd(ssl, client) == 0) {
          fprintf(stderr, "Unable to accept the client\n");
        } else {
          pthread_t thread = getWorker();
          pthread_create(&thread, NULL, threadHelper, ssl);
        }
      }
    }

    // Should never get here
    sem_destroy(&workPool);
    close(server);
    SSL_CTX_free(ctx); 
    pthread_exit(NULL);

  } catch (const char* err) {
    fprintf(stderr, "[ERROR] %s\n", err);
    return 1;
  }

  cleanup_openssl();

  return 0;
}
